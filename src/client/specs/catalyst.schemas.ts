/**
 * Generated by orval v6.16.0 üç∫
 * Do not edit manually.
 * API Specification for the Decentraland Catalyst Server (BETA)
 * A Catalyst is a Server that runs different services. These services currently work as the backbone for Decentraland and work in a decentralized network. The current specification details the following services: <br/><br/>- Archipelago <br/>- Content Server <br/>- Lambdas Service <br/> <br/>WARNING: We are working to close the version 1.0 of the Catalyst Protocol defined by this API. So far this is what we have and it's public but we are still working on refinement and during this process we may decided to deprecate or change some of the endpoints.
 * OpenAPI spec version: 1.0
 */
export type ValidateSignature200 = { [key: string]: any }

export type ValidateSignatureBody = { [key: string]: any }

export type SearchWearablesParams = {
  /**
   * Lis of URNs that identify the collection. Maximum amount of ids allowed is 500.
   */
  collectionId?: string[]
  /**
   * List of wearables URNs to search. Maximum amount of ids allowed is 500.
   */
  wearableId?: string[]
  /**
   * Search text
   */
  textSearch?: string
  /**
   * Limit the quantity of results that will be returned by the request. You can only request up to 500 results.
   */
  limit?: number
  /**
   * The result will always be ordered by the local timestamp fields but in case of timestamp collisions, you can use the lastId field to filter the result
   */
  lastId?: string
}

export type GetThirdPartyCollection200 = {
  elements: ThirdPartyWearable[]
  totalAmount: number
  pageNum: number
  pageSize: number
}

export type GetThirdPartyCollectionParams = {
  /**
   * The number of the requested page.
   */
  pageNum?: string
  /**
   * The size of the requested page.
   */
  pageSize?: string
}

export type GetThirdPartyWearables200 = {
  elements: ThirdPartyWearable[]
  totalAmount: number
  pageNum: number
  pageSize: number
}

export type GetThirdPartyWearablesParams = {
  /**
   * The number of the requested page.
   */
  pageNum?: string
  /**
   * The size of the requested page.
   */
  pageSize?: string
}

export type GetLandsParams = {
  /**
   * The number of the requested page. It needs `pageSize` to be present to enable a paginated response.
   */
  pageNum?: string
  /**
   * The size of the requested page. It needs `pageNum` to be present to enable a paginated response.
   */
  pageSize?: string
}

export type GetNamesParams = {
  /**
   * The number of the requested page. It needs `pageSize` to be present to enable a paginated response.
   */
  pageNum?: string
  /**
   * The size of the requested page. It needs `pageNum` to be present to enable a paginated response.
   */
  pageSize?: string
}

export type GetEmotes200 = {
  elements: Emote[]
  totalAmount: number
  pageNum: number
  pageSize: number
}

export type GetEmotesParams = {
  /**
   * Third Party collection Id to filter emotes, if this param is not sent then the 3rd parties emotes are not shown. If it is sent, only the 3rd parties emotes are shown.
   */
  collectionId?: string
  /**
   * If present, response will be extended with the entity data.
   */
  includeEntities?: boolean
  /**
   * The number of the requested page.
   */
  pageNum?: string
  /**
   * The size of the requested page
   */
  pageSize?: string
}

export type GetWearables200 = {
  elements: Wearable[]
  totalAmount: number
  pageNum: number
  pageSize: number
}

export type GetWearablesParams = {
  /**
   * If present, response will be extended with the entity data.
   */
  includeEntities?: boolean
  /**
   * If present, response will include the third-party wearables owned by the address. They will appear before other wearables if the response is paginated.
   */
  includeThirdParty?: boolean
  /**
   * The number of the requested page.
   */
  pageNum?: string
  /**
   * The size of the requested page.
   */
  pageSize?: string
  /**
   * Determines the field to be sort by. By default it will be by `transferredAt`. Possible values: `transferredAt` and `rarity`.
   */
  orderBy?: string
}

export type GetCollections200CollectionsItem = {
  id: string
  name: string
}

export type GetCollections200 = {
  collections?: GetCollections200CollectionsItem[]
}

export type GetPointerChangesSortingOrder =
  (typeof GetPointerChangesSortingOrder)[keyof typeof GetPointerChangesSortingOrder]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetPointerChangesSortingOrder = {
  ASC: 'ASC',
  DESC: 'DESC'
} as const

export type GetPointerChangesSortingField =
  (typeof GetPointerChangesSortingField)[keyof typeof GetPointerChangesSortingField]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetPointerChangesSortingField = {
  local_timestamp: 'local_timestamp',
  entity_timestamp: 'entity_timestamp'
} as const

export type GetPointerChangesEntityType = (typeof GetPointerChangesEntityType)[keyof typeof GetPointerChangesEntityType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GetPointerChangesEntityType = {
  scene: 'scene',
  profile: 'profile',
  wearable: 'wearable'
} as const

export type GetPointerChangesParams = {
  /**
   * Acts as a filter in the collection of deployments, this value is the minimum value of local timestamp that any deployment in the collection will have.
   */
  from?: number
  /**
   * Acts as a filter in the collection of deployments, this value is the maximum value of local timestamp that any deployment in the collection will have.
   */
  to?: number
  /**
   * It is the last entity id that was visited, so it will be skipped when showing current page.
   */
  lastId?: string
  /**
   * The deployments are a paginated collection, this parameter corresponds to the limit for each page. The default value is 500.
   */
  limit?: number
  /**
   * The type of entities that will be shown in the collection, many values can be sent. Valid values are: profile, scene and wearable.
   */
  entityType?: GetPointerChangesEntityType
  /**
   * This value is used as the field to order all the deployments in the collection. If no parameter is sent, then the default field to order with will be local_timestamp.
   */
  sortingField?: GetPointerChangesSortingField
  /**
   * This value is used as the order for all the deployments in the collection. If no parameter is sent, then the default field to order with will be DESC.
   */
  sortingOrder?: GetPointerChangesSortingOrder
}

export type GetActiveEntitiesBody = {
  /** Entities must be filtered by pointer XOR entityId (ids). Use this parameter if you want to retrieve an entity of the specified type with this pointer. */
  pointers?: string[]
  /** Entities must be filtered by pointer (pointers) XOR entityId. Use this parameter if you want to retrieve an entity of the specified type with this entityId. */
  ids?: string[]
}

export type GetEntitiesByPointerPrefix200 = {
  total: number
  entities: Entity[]
}

export type GetEntitiesByPointerPrefixParams = {
  /**
   * Page size (max 1000)
   */
  pageSize?: number
  /**
   * Page number (default: 1)
   */
  pageNumber?: number
}

export type PostEntity400 = Error | Errors

export type PostEntity200 = {
  creationTimestamp: number
}

export type PostEntityBody = {
  files?: Blob[]
  entityId?: string
  authChain?: string
  ethAddress?: string
  signature?: string
}

export type GetAvailableContentParams = {
  /**
   * Hash of the content file
   */
  cid: string[]
}

export type GetEntityIdsByHashId404 = {
  error: string
}

export type GetChallenge200 = {
  challengeText: string
}

export type PeersPeersItem = {
  id?: string
  address?: string
  parcel?: number[]
  position?: number[]
  lastPing?: number
}

export interface Peers {
  ok?: boolean
  peers?: PeersPeersItem[]
}

export type IslandIdPeersItem = {
  id?: string
  address?: string
  parcel?: number[]
  position?: number[]
  lastPing?: number
  preferedIslandId?: string
}

export interface IslandId {
  id?: string
  peers?: IslandIdPeersItem[]
  maxPeers?: number
  center?: number[]
  radius?: number
}

export type IslandsIslandsItemPeersItem = {
  id?: string
  address?: string
  parcel?: number[]
  position?: number[]
  lastPing?: number
  preferedIslandId?: string
}

export type IslandsIslandsItem = {
  id?: string
  peers?: IslandsIslandsItemPeersItem[]
  maxPeers?: number
  center?: number[]
  radius?: number
}

export interface Islands {
  ok?: boolean
  islands?: IslandsIslandsItem[]
}

export type ThirdPartyIntegrationsDataItem = {
  urn: string
  name?: string
  description?: string
}

export interface ThirdPartyIntegrations {
  data: ThirdPartyIntegrationsDataItem[]
}

export type ProfileAvatarsItem = {
  userId?: string
  email?: string
  name?: string
  hasClaimedName?: boolean
  description?: string
  ethAddress?: string
  version?: number
  avatar?: ProfileAvatarsItemAvatar
  tutorialStep?: number
  interests?: string[]
  unclaimedName?: string
}

export interface Profile {
  avatars?: ProfileAvatarsItem[]
}

export type ProfileAvatarsItemAvatarSkinColor = {
  r?: number
  g?: number
  b?: number
}

export type ProfileAvatarsItemAvatarSkin = {
  color?: ProfileAvatarsItemAvatarSkinColor
}

export type ProfileAvatarsItemAvatarHairColor = {
  r?: number
  g?: number
  b?: number
}

export type ProfileAvatarsItemAvatarHair = {
  color?: ProfileAvatarsItemAvatarHairColor
}

export type ProfileAvatarsItemAvatarEyesColor = {
  r?: number
  g?: number
  b?: number
}

export type ProfileAvatarsItemAvatarEyes = {
  color?: ProfileAvatarsItemAvatarEyesColor
}

export type ProfileAvatarsItemAvatarSnapshots = {
  face?: string
  face128?: string
  face256?: string
  body?: string
}

export type ProfileAvatarsItemAvatar = {
  bodyShape?: string
  snapshots?: ProfileAvatarsItemAvatarSnapshots
  eyes?: ProfileAvatarsItemAvatarEyes
  hair?: ProfileAvatarsItemAvatarHair
  skin?: ProfileAvatarsItemAvatarSkin
  wearables?: string[]
}

export interface PostProfiles {
  ids?: string[]
}

export type RealmsItem = {
  serverName?: string
  url?: string
  layer?: string
  usersCount?: number
  maxUsers?: number
  userParcels?: number[][]
}

export type Realms = RealmsItem[]

export type HotScenesItemRealmsItem = {
  serverName?: string
  url?: string
  layer?: string
  usersCount?: number
  maxUsers?: number
  userParcels?: number[][]
}

export type HotScenesItem = {
  id?: string
  name?: string
  baseCoords?: number[]
  usersTotalCount?: number
  parcels?: number[][]
  thumbnail?: string
  creator?: string
  description?: string
  realms?: HotScenesItemRealmsItem[]
}

export type HotScenes = HotScenesItem[]

export type DenylistedUsernames = string[]

export type Pois = string[]

export type ServersItem = {
  baseUrl?: string
  owner?: string
  id?: string
}

export type Servers = ServersItem[]

export type WearablesPagination = {
  limit?: number
  next?: string
}

export type WearablesFilters = {
  textSearch?: string
}

export type WearablesWearablesItemI18nItem = {
  code?: string
  text?: string
}

export type WearablesWearablesItem = {
  id?: string
  description?: string
  image?: string
  thumbnail?: string
  collectionAddress?: string
  rarity?: string
  data?: WearablesWearablesItemData
  i18n?: WearablesWearablesItemI18nItem[]
  createdAt?: number
  updatedAt?: number
}

export interface Wearables {
  wearables?: WearablesWearablesItem[]
  filters?: WearablesFilters
  pagination?: WearablesPagination
}

export type WearablesWearablesItemDataRepresentationsItemContentsItem = {
  key?: string
  url?: string
}

export type WearablesWearablesItemDataRepresentationsItemOverrideHidesItem = { [key: string]: any }

export type WearablesWearablesItemDataRepresentationsItemOverrideReplacesItem = { [key: string]: any }

export type WearablesWearablesItemDataRepresentationsItem = {
  bodyShapes?: string[]
  mainFile?: string
  overrideReplaces?: WearablesWearablesItemDataRepresentationsItemOverrideReplacesItem[]
  overrideHides?: WearablesWearablesItemDataRepresentationsItemOverrideHidesItem[]
  contents?: WearablesWearablesItemDataRepresentationsItemContentsItem[]
}

export type WearablesWearablesItemData = {
  replaces?: string[]
  hides?: string[]
  tags?: string[]
  category?: string
  representations?: WearablesWearablesItemDataRepresentationsItem[]
}

export type ThirdPartyWearableIndividualDataItem = {
  id?: string
}

export interface ThirdPartyWearable {
  urn: string
  amount?: number
  name: string
  category: string
  entity: Entity
  individualData?: ThirdPartyWearableIndividualDataItem[]
}

export type LandsPaginatedElementsItem = {
  name?: string
  contractAddress: string
  tokenId: string
  price?: number
  category: string
  x?: string
  y?: string
  image?: string
  description?: string
}

export interface LandsPaginated {
  elements: LandsPaginatedElementsItem[]
  totalAmount: number
  pageNum: number
  pageSize: number
}

export type NamesPaginatedElementsItem = {
  name: string
  contractAddress: string
  tokenId: string
  price?: number
}

export interface NamesPaginated {
  elements: NamesPaginatedElementsItem[]
  totalAmount: number
  pageNum: number
  pageSize: number
}

export interface LambdasError {
  error: string
  message: string
}

export type WearableIndividualDataItem = {
  id?: string
  tokenId?: string
  transferredAt?: number
  price?: number
}

export interface Wearable {
  urn: string
  amount?: number
  name: string
  rarity: string
  category: string
  entity?: Entity
  individualData?: WearableIndividualDataItem[]
}

export type Erc721AttributesItem = {
  trait_type?: string
  value?: string
}

export interface Erc721 {
  id?: string
  name?: string
  description?: string
  language?: string
  image?: string
  thumbnail?: string
  attributes?: Erc721AttributesItem[]
}

export interface StatusLambdas {
  version?: string
  currentTime?: number
  contentServerUrl?: string
  commitHash?: string
  catalystVersion?: string
}

export type StatusContentSynchronizationStatusOtherServersItem = {
  address: string
  connectionState: string
  lastDeploymentTimestamp: number
}

export type StatusContentSynchronizationStatus = {
  otherServers?: StatusContentSynchronizationStatusOtherServersItem[]
  lastSyncWithDAO: number
  synchronizationState: string
  lastSyncWithOtherServers?: number
}

export interface StatusContent {
  name?: string
  version: string
  currentTime?: number
  lastImmutableTime?: number
  historySize?: number
  synchronizationStatus: StatusContentSynchronizationStatus
  commitHash: string
  catalystVersion: string
  ethNetwork: string
}

export type SnapshotsItemTimeRange = {
  initTimestamp: number
  endTimestamp: number
}

export type SnapshotsItem = {
  hash: string
  timeRange: SnapshotsItemTimeRange
  replacedSnapshotHashes?: string[]
  numberOfEntities: number
  generationTimestamp: number
}

export type Snapshots = SnapshotsItem[]

export type PointerChangesDeltasItem = {
  entityType: string
  entityId: string
  localTimestamp: number
  pointers: string[]
  authChain: AuthChain
}

export interface PointerChanges {
  deltas: PointerChangesDeltasItem[]
}

export type FailedDeploymentsItem = {
  failedDeploymentsRepo?: string
  entityType: string
  entityId: string
  reason: string
  errorDescription: string
}

export type FailedDeployments = FailedDeploymentsItem[]

export type EntityMetadata = { [key: string]: any }

export type EntityContentItem = {
  file: string
  hash: string
}

export interface Entity {
  version: string
  id: string
  type: string
  timestamp: number
  pointers: string[]
  content: EntityContentItem[]
  metadata?: EntityMetadata
}

export interface Emote {
  urn: string
  amount?: number
  category: string
  entity?: Entity
}

export interface Errors {
  errors: string[]
}

export type AvailableContentItem = {
  cid: string
  available: boolean
}

export type AvailableContent = AvailableContentItem[]

export interface Error {
  error: string
}

export type AuthChainItem = {
  type: string
  payload: string
  signature?: string
}

export type AuthChain = AuthChainItem[]

export interface AuditResponse {
  version: string
  localTimestamp: number
  authChain: AuthChain
  overwrittenBy?: string
  isDenylisted?: boolean
  denylistedContent?: string[]
}

export type StatsParcelsParcelsItemParcel = {
  x?: number
  y?: number
}

export type StatsParcelsParcelsItem = {
  peersCount?: number
  parcel?: StatsParcelsParcelsItemParcel
}

export interface StatsParcels {
  parcels?: StatsParcelsParcelsItem[]
}

export type AboutBff = {
  healthy: boolean
  commitHash?: string
  usersCount?: number
  publicUrl: string
  protocolVersion: string
}

export type AboutLambdas = {
  healthy: boolean
  commitHash?: string
  version?: string
  publicUrl: string
}

export type AboutComms = {
  healthy: boolean
  protocol: string
  commitHash?: string
  userCount?: string
}

export type AboutContent = {
  healthy: boolean
  commitHash?: string
  version?: string
  publicUrl: string
}

export interface About {
  healthy: boolean
  acceptingUsers: boolean
  configurations: AboutConfigurations
  content: AboutContent
  comms: AboutComms
  lambdas: AboutLambdas
  bff?: AboutBff
}

export type AboutConfigurationsSkybox = {
  fixedHour?: number
}

export type AboutConfigurationsMinimap = {
  enabled: boolean
  dataImage?: string
  estateImage?: string
}

export type AboutConfigurations = {
  realmName?: string
  networkId: number
  globalScenesUrn: string[]
  scenesUrn: string[]
  minimap?: AboutConfigurationsMinimap
  skybox?: AboutConfigurationsSkybox
}
